#!/usr/bin/python

from __future__ import print_function

import os, sys, subprocess, errno, signal
import multiprocessing.queues
import collections, functools, itertools
import logging
import time
import argparse
import traceback

import ptrace.debugger
import ptrace.func_call
import ptrace.syscall

logging.basicConfig(level=logging.DEBUG, format="%(message)s")
log = logging.getLogger('tests')

import patch

class Data(object):
    def __str__(self):
        return self.template.format(**vars(self))

    def __repr__(self):
        return repr(str(self))

class Socket(Data):
    template = "{fd}/{domain.text}/{socktype.text}/{protocol.text}"

    def __init__(self, syscall):
        self.fd = syscall.result
        self.domain, self.socktype, self.protocol = syscall.arguments
        self.time = syscall.time

class Argument:
    template = "{name} = {value} ({text})"

    def __init__(self, arg):
        self.name = arg.name
        self.value = arg.value
        self.text = arg.text

class Syscall:
    template = "[{timestamp:.3f} {origin} {pid}] {info} = {result}"

    def __init__(self, debugger_process, syscall_event):
        self.origin = debugger_process.name
        self.pid = syscall_event.process.pid
        self.name = syscall_event.name
        self.result = syscall_event.result
        self.arguments = [Argument(arg) for arg in syscall_event.arguments]
        self.timestamp = time.time()
        self.info = syscall_event.format()

class Property:
    def __init__(self, arg):
        self.arg = arg

    def __str__(self):
        return self.template.format(**vars(self))

class DebuggerProcess(multiprocessing.Process):
    def __init__(self, name, command, queue):
        log.debug("Created debugger: {}".format(command))
        super(DebuggerProcess, self).__init__(name=name)
        self.q = queue
        self.__command = command
        #self.__command = ['ip', 'netns', 'exec', 'test-loopback', 'wrapresolve', 'testcases/netresolve/client']

    def run(self):
        debugger = ptrace.debugger.PtraceDebugger()

        try:
            debugger.traceFork()
            debugger.traceExec()
            self.__process = debugger.addProcess(ptrace.debugger.child.createChild(self.__command, False), True)
            self.__process.syscall()
            self.__started = time.time()

            log.debug("Debugging processes: pid={} dict={}".format(self.__process.pid, debugger.dict))

            while debugger.dict:
                try:
                    event = debugger.waitSyscall()
                    #event.display()
                except ptrace.debugger.process_event.ProcessExit as event:
                    process = event.process
                    #origin = process.origin

                    log.debug("[{}] Process exited: {} {}".format(self.name, process.pid, event.exitcode))
                    continue
    #                #if process == self.server:
    #                    if debugger.dict:
    #                        self.error("Server returned but there are still processes running.")
    #                    if event.exitcode:
    #                        self.info("Server returned with non-zero exit code.")
    #                if process == self.client:
    #                    if event.exitcode:
    #                        self.error("Client exit code with {}.".format(event.exitcode))
    #                    log.info("Client is gone, exiting.")
    #                    break;
                except ptrace.debugger.ProcessSignal as event:
                    process = event.process
                    event.display()
                    if event.signum & 0x80:
                        raise
                    process.syscall(event.signum)
                    continue
    #            else:
    #                if syscall.result is not None:
    #                    names = ptrace.syscall.SOCKET_SYSCALL_NAMES | set(['close', 'execve', 'fork', 'clone'])
    #                    if syscall.name == 'close' and (syscall.pid, syscall.arguments[0].value) not in self.sockets:
    #                        process.syscall()
    #                        continue
    #                    if syscall.name in set(['bind', 'listen', 'connect']):
    #                        syscall.socket = self.sockets[syscall.pid, syscall.arguments[0].value]
    #                    if syscall.name in names:
    #                        log.debug(syscall)
    #                        self.syscalls.append(syscall)
    #                        if syscall.origin == 'server':
    #                            self.server_syscall(syscall)
    #                        elif syscall.origin == 'client':
    #                            self.client_syscall(syscall)
    #                        else:
    #                            self.error("Network syscall of unknown origin: {}".format(syscall))
    #                process.syscall()
    #    except BaseException as error:
    #        self.error("Python exception {} occured: {}".format(type(error), error))
    #        raise
                except ptrace.debugger.process_event.NewProcessEvent as event:
                    process = event.process
                    #origin = process.origin = process.parent.origin

                    log.info("[{}] New process: {}".format(self.name, process.pid))

                    process.parent.syscall()
                    process.syscall()
                    continue
                except ptrace.debugger.process_event.ProcessExecution as event:
                    process = event.process
                    #origin = process.origin = process.parent.origin

                    log.info(event)

                    process.syscall()
                    continue

                process = event.process

                syscall = Syscall(self, process.syscall_state.event(ptrace.func_call.FunctionCallOptions()))
                #log.debug(syscall)
                self.q.put((self.name, syscall))

                process.syscall()
        except BaseException as error:
            log.error(error)
            raise
        finally:
            log.debug("Debugged processes: pid={} dict={}".format(self.__process.pid, debugger.dict))
            debugger.quit()
            self.q.put((self.name, None))
    #self.cleanup()

class PreferredFamily(Property):
    template = "Preferred address family is {arg}."

class PreferredLoopbackFamily(PreferredFamily):
    template = "Preferred loopback address family is {family}."

class ParallelConnect(Property):
    template = "Connection method is {method}. {description}"

    def __init__(self, flag):
        if flag:
            self.method = "parallel"
            self.description = "This is a happy eyeballs style dual-stack connection method resulting in fast fallback when the preferred address family fails silently."
        else:
            self.method = "sequential"
            self.description = "This is a classic dual-stack connection method resulting in a significant timeout when the preferred address family fails silently."

class FallbackDelay(Property):
    template = "Fallback delay is {arg:.3f}."

class Scenario(object):
    client = server = None

    class _Timeout(Exception):
        pass

    def __init__(self, testcase, options):
        self.testcase = testcase
        self.options = options
        self.namespaces = []
        self.messages = []
        self.sockets = {}
        self.syscalls = []
        self.listening = set()
        self.properties = []

    def _wait(self):
        now = time.time()
        if now > self.deadline:
            raise self._Timeout()
        message = self.queue.get(self.deadline - now)
        self.syscalls.append(message)
        return message

    def wait(self, origin=None, syscall=None):
        while True:
            o, s = self._wait()
            if o != origin.name:
                continue
            if s is None:
                break
            if s.name == syscall:
                break
        return o, s

    def run(self):
        self.prepare()
        self.queue = multiprocessing.Queue()
        self.server = DebuggerProcess("server", self.command(self.testcase.name, "server"), self.queue)
        self.client = DebuggerProcess("client", self.command(self.testcase.name, "client"), self.queue)

        self.deadline = time.time() + 2

        try:
            self.server.start()
            self.wait(self.server, "listen")
            self.wait(self.server, "listen")

            self.client.start()
            self.wait(self.client)
        except self._Timeout:
            pass
        finally:
            for process in (self.client, self.server):
                process.terminate()
                process.join()

        log.debug('**********************')
        [print(i) for i in self.syscalls]
        log.debug('**********************')
        sys.exit(0)
        try:

            log.info("\n*** {} / {} ***\n".format(self.testcase.name, self.name))

            try:

                while self.debugger.dict:
                    #log.debug('-' * 79)
                    try:
                        event = self.debugger.waitSyscall()
                        process = event.process
                        syscall = Syscall(process.syscall_state.event(ptrace.func_call.FunctionCallOptions()), time.time() - self.started)
                    except ptrace.debugger.process_event.NewProcessEvent as event:
                        process = event.process
                        origin = process.origin = process.parent.origin

                        log.info("[{}] New process: {}".format(origin, process.pid))

                        event.process.parent.syscall()
                        process.syscall()
                    except ptrace.debugger.process_event.ProcessExit as event:
                        process = event.process
                        origin = process.origin

                        log.debug("[{}] Process exited: {} {}".format(origin, process.pid, event.exitcode))
                        if process == self.server:
                            if self.debugger.dict:
                                self.error("Server returned but there are still processes running.")
                            if event.exitcode:
                                self.info("Server returned with non-zero exit code.")
                        if process == self.client:
                            if event.exitcode:
                                self.error("Client exit code with {}.".format(event.exitcode))
                            log.info("Client is gone, exiting.")
                            break;
                    except ptrace.debugger.ptrace_signal.ProcessSignal as event:
                        process = event.process
                        origin = process.origin
                        log.debug("[{}] Signal received: {} {}".format(origin, process.pid, event.signum))

                        process.syscall(event.signum)
                    else:
                        if syscall.result is not None:
                            names = ptrace.syscall.SOCKET_SYSCALL_NAMES | set(['close', 'execve', 'fork', 'clone'])
                            if syscall.name == 'close' and (syscall.pid, syscall.arguments[0].value) not in self.sockets:
                                process.syscall()
                                continue
                            if syscall.name in set(['bind', 'listen', 'connect']):
                                syscall.socket = self.sockets[syscall.pid, syscall.arguments[0].value]
                            if syscall.name in names:
                                log.debug(syscall)
                                self.syscalls.append(syscall)
                                if syscall.origin == 'server':
                                    self.server_syscall(syscall)
                                elif syscall.origin == 'client':
                                    self.client_syscall(syscall)
                                else:
                                    self.error("Network syscall of unknown origin: {}".format(syscall))
                        process.syscall()
            except BaseException as error:
                self.error("Python exception {} occured: {}".format(type(error), error))
                raise
        finally:
            self.debugger.quit()
            self.cleanup()
        self.postprocess()

    def server_syscall(self, syscall):
        if syscall.name == 'socket':
            sock = Socket(syscall)
            if sock.fd >= 0:
                self.sockets[syscall.pid, sock.fd] = sock
            else:
                self.error("Server failed to create socket: {}".format(sock))
        if syscall.name == 'bind':
            sock = self.sockets[syscall.pid, syscall.arguments[0].value]

            if syscall.result != 0 and sock.domain.text not in self.listening:
                self.listening.add(sock.domain.text)

                if 'AF_INET' in self.listening and 'AF_INET6' in self.listening:
                    self.client = self.start('client')

        if syscall.name == 'listen':
            sock = self.sockets[syscall.pid, syscall.arguments[0].value]

            if sock.domain.text not in self.listening:
                self.listening.add(sock.domain.text)

                if 'AF_INET' in self.listening and 'AF_INET6' in self.listening:
                    self.client = self.start('client')

    def client_syscall(self, syscall):
        if syscall.name == 'socket':
            sock = Socket(syscall)
            if sock.fd >= 0:
                self.sockets[syscall.pid, sock.fd] = sock
            else:
                self.error("Client failed to create socket: {}".format(sock))
        if syscall.name == 'close':
            sock = self.sockets.pop((syscall.pid, syscall.arguments[0].value), None)
        if syscall.name == 'connect':
            sock = self.sockets.get((syscall.pid, syscall.arguments[0].value))
            if syscall.result == 0:
                if sock.protocol.value != 0:
                    self.info("Client connected: {} -> {}".format(sock, syscall))
            elif syscall.result == -errno.EINPROGRESS:
                self.info("Client connecting in non-blocking mode.")
            else:
                self.error("Client failed to connect: {} -> {}".format(sock, syscall))

    def start(self, origin):
        return DebuggerProcess(origin, self.command(self.testcase.name, origin))


        log.debug("Starting {origin}: {command}".format(**locals()))
        try:
            pid = ptrace.debugger.child.createChild(command, False)
        except ptrace.debugger.child.ChildError as error:
            self.info("Could not run Script '{}': {}".format(origin, error))
            pid = ptrace.debugger.child.createChild(['/bin/true'], False)

        process = self.debugger.addProcess(pid, True)
        process.origin = origin
        process.syscall()

        return process

    def client_exited(self):
        pass

    def error(self, message):
        log.error(message)
        self.message(('error', message))

    def info(self, message):
        self.message(('info', message))

    def __str__(self):
        return self.name

    def prepare(self):
        os.environ['NETRESOLVE_BACKENDS'] = 'any|loopback|numerichost|hosts';
        os.environ['NETRESOLVE_SYSCONFDIR'] = os.getcwd();
        os.environ['DEFAULT_SERVICE'] = 'http'

    def cleanup(self):
        for ns in self.namespaces:
            subprocess.call(['ip', 'netns', 'delete', ns])

    def postprocess(self):
        pass

    def _add_netns(self, ns):
        self.namespaces.append(ns)
        subprocess.call(['ip', 'netns', 'delete', ns])
        subprocess.check_call(['ip', 'netns', 'add', ns])
        subprocess.check_call(['ip', '-n', ns, 'link', 'set', 'lo', 'up'])

    def _add_veth(self, ns1, ns2):
        link1, link2 = ns1, ns2
        subprocess.check_call(['ip', 'link', 'add', 'dev', link1, 'type', 'veth', 'peer', 'name', link2])
        for ns, link in (ns1, link1), (ns2, link2):
            subprocess.check_call(['ip', 'link', 'set', link, 'netns', ns, 'up'])

    def _add_address(self, ns, link, address):
        subprocess.check_call(['ip', '-n', ns, 'address', 'add', address, 'dev', link])

    def message(self, message):
        self.messages.append(message)

    def report(self):
        print('    ' + self.name)
        for message in self.messages:
            print('      ' + str(message))

    def _connections(self):
        preferred = None
        fallback = None

        for syscall in self.syscalls:
            if syscall.origin == 'client' and syscall.name == 'connect':
                if syscall.arguments[1].text.startswith('<sockaddr_in sin_family=2, sin_port=0,'):
                    continue
                if syscall.arguments[1].text.startswith('<sockaddr_in6 sin6_family=10, sin6_port=0, sin6_flowinfo=0L,'):
                    continue

                if preferred is None:
                    preferred = syscall
                elif fallback is None:
                    fallback = syscall
                else:
                    self.message(('error', 'Third connection attempt detected.'))

        return preferred, fallback

class LoopbackScenario(Scenario):
    name = 'loopback'

    def prepare(self):
        super(self.__class__, self).prepare()
        os.environ['SOURCE'] = os.environ['DESTINATION'] = 'localhost'
        self._add_netns('test-loopback')

    def command(self, name, origin):
        return [
                'ip',
                'netns',
                'exec',
                'test-loopback',
                'wrapresolve',
                'testcases/{}/{}'.format(name, origin)]

class DualstackScenario(Scenario):
    name = 'dualstack'

    source_ns = 'test-client'
    destination_ns = 'test-server'
    source_link, destination_link = source_ns, destination_ns
    destination_config = ['192.0.2.1/24', '2001:DB8::2:1/64']
    source_config = ['192.0.2.2/24', '2001:DB8::2:2/64']

    def prepare(self):
        super(DualstackScenario, self).prepare()
        os.environ['SOURCE'] = 'client.example.net'
        os.environ['DESTINATION'] = 'server.example.net'
        for ns in self.source_ns, self.destination_ns:
            self._add_netns(ns)
        self._add_veth(self.source_ns, self.destination_ns)
        for address in self.source_config:
            self._add_address(self.source_ns, self.source_link, address)
        for address in self.destination_config:
            self._add_address(self.destination_ns, self.destination_link, address)

    def command(self, name, origin):
        return [
                'ip',
                'netns',
                'exec',
                'test-{}'.format(origin),
                'wrapresolve',
                'testcases/{}/{}'.format(name, origin)]

    def postprocess(self):
        preferred, fallback = self._connections()

        log.debug([fallback == preferred])

        self.properties.append(ParallelConnect(bool(fallback)))

class IP6DroppedScenario(DualstackScenario):
    name = 'v6dropped'

    def prepare(self):
        super(IP6DroppedScenario, self).prepare()
        subprocess.check_call(['ip', 'netns', 'exec', 'test-client', 'ip6tables', '-A', 'OUTPUT', '-j', 'DROP'])

    def postprocess(self):
        preferred, fallback = self._connections()

        if preferred and fallback:
            self.properties.append(FallbackDelay(fallback.socket.time - preferred.socket.time))

class Testcase:
    scenario_classes = [LoopbackScenario, DualstackScenario, IP6DroppedScenario]

    def __init__(self, name, scenarios, options):
        self.name = name
        self.scenarios = [cls(self, options) for cls in self.scenario_classes]
        if scenarios:
            self.scenarios = [scenario for scenario in self.scenarios if scenario.name in scenarios]

    def run(self):
        for scenario in self.scenarios:
            scenario.run()

    def report(self):
        print(self.name)
        print("  Scenarios:")
        for scenario in self.scenarios:
            scenario.report()
        print("  Properties:")
        for property in sum((scenario.properties for scenario in self.scenarios), []):
            print("    {}".format(property))
        print()

class TestSuite:
    def __init__(self, testcases, scenarios, options):
        self.testcases = [Testcase(name, scenarios, options) for name in os.listdir('testcases')]
        if testcases:
            self.testcases = [testcase for testcase in self.testcases if testcase.name in testcases]

    def run(self):
        for testcase in self.testcases:
            testcase.run()

    def report(self):
        print()
        for testcase in self.testcases:
            testcase.report()

def main():
    parser = argparse.ArgumentParser(description="Test driver for client-server networking applications.")
    parser.add_argument("--list", "-l", action="store_true", help="List testcases and scenarios.")
    parser.add_argument("--client-timeout", default="20", help="List testcases and scenarios.")
    parser.add_argument("testcases", nargs="?")
    parser.add_argument("scenarios", nargs="?")
    options = parser.parse_args()

    testcases = options.testcases and options.testcases
    scenarios = options.scenarios and options.scenarios

    suite = TestSuite(testcases, scenarios, options)
    if not options.list:
        suite.run()
    print(suite)
    print(suite.testcases)
    suite.report()

if __name__ == '__main__':
    main()
