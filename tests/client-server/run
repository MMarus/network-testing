#!/usr/bin/python

from __future__ import print_function

import os, sys, subprocess, errno
import collections, functools, itertools
import logging
import time
import argparse

import ptrace.debugger
import ptrace.func_call
import ptrace.syscall

logging.basicConfig(level=logging.DEBUG, format="%(message)s")
log = logging.getLogger('tests')

#
# Patch python-ptrace on the fly
#

def patch(module):
    def _patch(new):
        setattr(module, new.__name__, new)
    return _patch

# Change execve/execv to execvpe/execvp
@patch(ptrace.debugger.child)
def _execChild(arguments, no_stdout, env):
    if no_stdout:
        try:
            null = open(devnull, 'wb')
            os.dup2(null.fileno(), 1)
            os.dup2(1, 2)
            null.close()
        except IOError as err:
            os.close(2)
            os.close(1)
    try:
        if env is not None:
            os.execvpe(arguments[0], arguments, env)
        else:
            os.execvp(arguments[0], arguments)
    except Exception as err:
        raise ptrace.debugger.child.ChildError(str(err))

#
#
#

class Socket:
    def __init__(self, syscall):
        self.fd = syscall.result
        self.domain, self.socktype, self.protocol = syscall.arguments
        self.time = syscall.time

    def __str__(self):
        return "{fd}/{domain.text}/{socktype.text}/{protocol.text}".format(**vars(self))

class Syscall:
    def __init__(self, syscall_event, time):
        self.origin = syscall_event.process.origin
        self.pid = syscall_event.process.pid
        self.name = syscall_event.name
        self.result = syscall_event.result
        self.arguments = syscall_event.arguments
        self.time = time
        self.__string = "[{time:.3f} {origin} {pid}] {format} = {result}".format(format=syscall_event.format(), **vars(self))

    def __str__(self):
        return self.__string

class Property:
    def __init__(self, arg):
        self.arg = arg

    def __str__(self):
        return self.template.format(**vars(self))

class PreferredFamily(Property):
    template = "Preferred address family is {arg}."

class PreferredLoopbackFamily(PreferredFamily):
    template = "Preferred loopback address family is {family}."

class ParallelConnect(Property):
    template = "Connection method is {method}. {description}"

    def __init__(self, flag):
        if flag:
            self.method = "parallel"
            self.description = "This is a happy eyeballs style dual-stack connection method resulting in fast fallback when the preferred address family fails silently."
        else:
            self.method = "sequential"
            self.description = "This is a classic dual-stack connection method resulting in a significant timeout when the preferred address family fails silently."

class FallbackDelay(Property):
    template = "Fallback delay is {arg:.3f}."

class Scenario(object):
    client = server = None

    def __init__(self, testcase):
        self.namespaces = []
        self.testcase = testcase
        self.messages = []
        self.sockets = {}
        self.syscalls = []
        self.listening = set()

    def run(self):
        self.prepare()
        try:
            self.debugger = ptrace.debugger.PtraceDebugger()
            self.debugger.traceFork()
            self.started = time.time()

            log.info("\n*** {} / {} ***\n".format(self.testcase.name, self.name))

            try:
                self.server = self.start("server")

                while self.debugger.dict:
                    #log.debug('-' * 79)
                    try:
                        event = self.debugger.waitSyscall()
                        process = event.process
                        syscall = Syscall(process.syscall_state.event(ptrace.func_call.FunctionCallOptions()), time.time() - self.started)
                    except ptrace.debugger.process_event.NewProcessEvent as event:
                        process = event.process
                        origin = process.origin = process.parent.origin

                        log.info("[{}] New process: {}".format(origin, process.pid))

                        event.process.parent.syscall()
                        process.syscall()
                    except ptrace.debugger.process_event.ProcessExit as event:
                        process = event.process
                        origin = process.origin

                        log.debug("[{}] Process exited: {} {}".format(origin, process.pid, event.exitcode))
                        if process == self.server:
                            if self.debugger.dict:
                                self.error("Server returned but there are still processes running.")
                            if event.exitcode:
                                self.info("Server returned with non-zero exit code.")
                        if process == self.client:
                            self.error("Client exit code with {}.".format(event.exitcode))
                            log.info("Client is gone, exiting.")
                            break;
                    except ptrace.debugger.ptrace_signal.ProcessSignal as event:
                        process = event.process
                        origin = process.origin
                        log.debug("[{}] Signal received: {} {}".format(origin, process.pid, event.signum))

                        process.syscall(event.signum & ~0x80)
                    else:
                        if syscall.result is not None:
                            names = ptrace.syscall.SOCKET_SYSCALL_NAMES | set(['close', 'execve', 'fork', 'clone'])
                            if syscall.name == 'close' and (syscall.pid, syscall.arguments[0].value) not in self.sockets:
                                process.syscall()
                                continue
                            if syscall.name in set(['bind', 'listen', 'connect']):
                                syscall.socket = self.sockets[syscall.pid, syscall.arguments[0].value]
                            if syscall.name in names:
                                log.debug(syscall)
                                self.syscalls.append(syscall)
                                if syscall.origin == 'server':
                                    self.server_syscall(syscall)
                                elif syscall.origin == 'client':
                                    self.client_syscall(syscall)
                                else:
                                    self.error("Network syscall of unknown origin: {}".format(syscall))
                        process.syscall()
            except BaseException as error:
                self.error("Python exception {} occured: {}".format(type(error), error))
                raise
        finally:
            self.debugger.quit()
            self.cleanup()
        self.postprocess()

    def server_syscall(self, syscall):
        if syscall.name == 'socket':
            sock = Socket(syscall)
            if sock.fd >= 0:
                self.sockets[syscall.pid, sock.fd] = sock
            else:
                self.error("Server failed to create socket: {}".format(sock))
        if syscall.name == 'bind':
            sock = self.sockets[syscall.pid, syscall.arguments[0].value]

            if syscall.result != 0 and sock.domain.text not in self.listening:
                self.listening.add(sock.domain.text)

                if 'AF_INET' in self.listening and 'AF_INET6' in self.listening:
                    self.client = self.start('client')

        if syscall.name == 'listen':
            sock = self.sockets[syscall.pid, syscall.arguments[0].value]

            if sock.domain.text not in self.listening:
                self.listening.add(sock.domain.text)

                if 'AF_INET' in self.listening and 'AF_INET6' in self.listening:
                    self.client = self.start('client')

    def client_syscall(self, syscall):
        if syscall.name == 'socket':
            sock = Socket(syscall)
            if sock.fd >= 0:
                self.sockets[syscall.pid, sock.fd] = sock
            else:
                self.error("Client failed to create socket: {}".format(sock))
        if syscall.name == 'close':
            sock = self.sockets.pop((syscall.pid, syscall.arguments[0].value), None)
        if syscall.name == 'connect':
            sock = self.sockets.get((syscall.pid, syscall.arguments[0].value))
            if syscall.result == 0:
                if sock.protocol.value != 0:
                    self.info("Client connected: {} -> {}".format(sock, syscall))
            elif syscall.result == -errno.EINPROGRESS:
                self.info("Client connecting in non-blocking mode.")
            else:
                self.error("Client failed to connect: {} -> {}".format(sock, syscall))

    def start(self, origin):
        command = self.command(self.testcase.name, origin)

        log.debug("Starting {origin}: {command}".format(**locals()))
        try:
            pid = ptrace.debugger.child.createChild(command, False)
        except ptrace.debugger.child.ChildError as error:
            self.info("Could not run Script '{}': {}".format(origin, error))
            pid = ptrace.debugger.child.createChild(['/bin/true'], False)

        process = self.debugger.addProcess(pid, True)
        process.origin = origin
        process.syscall()

        return process

    def client_exited(self):
        pass

    def error(self, message):
        self.message(('error', message))

    def info(self, message):
        self.message(('info', message))

    def __str__(self):
        return self.name

    def prepare(self):
        os.environ['NETRESOLVE_BACKENDS'] = 'any|loopback|numerichost|hosts';
        os.environ['NETRESOLVE_SYSCONFDIR'] = os.getcwd();
        os.environ['DEFAULT_SERVICE'] = 'http'

    def cleanup(self):
        for ns in self.namespaces:
            subprocess.call(['ip', 'netns', 'delete', ns])

    def postprocess(self):
        pass

    def _add_netns(self, ns):
        self.namespaces.append(ns)
        subprocess.call(['ip', 'netns', 'delete', ns])
        subprocess.check_call(['ip', 'netns', 'add', ns])
        subprocess.check_call(['ip', '-n', ns, 'link', 'set', 'lo', 'up'])

    def _add_veth(self, ns1, ns2):
        link1, link2 = ns1, ns2
        subprocess.check_call(['ip', 'link', 'add', 'dev', link1, 'type', 'veth', 'peer', 'name', link2])
        for ns, link in (ns1, link1), (ns2, link2):
            subprocess.check_call(['ip', 'link', 'set', link, 'netns', ns, 'up'])

    def _add_address(self, ns, link, address):
        subprocess.check_call(['ip', '-n', ns, 'address', 'add', address, 'dev', link])

    def message(self, message):
        self.messages.append(message)

    def report(self):
        print('    ' + self.name)
        for message in self.messages:
            print('      ' + str(message))

    def _connections(self):
        preferred = None
        fallback = None

        for syscall in self.syscalls:
            if syscall.origin == 'client' and syscall.name == 'connect':
                if syscall.arguments[1].text.startswith('<sockaddr_in sin_family=2, sin_port=0,'):
                    continue
                if syscall.arguments[1].text.startswith('<sockaddr_in6 sin6_family=10, sin6_port=0, sin6_flowinfo=0L,'):
                    continue

                if preferred is None:
                    preferred = syscall
                elif fallback is None:
                    fallback = syscall
                else:
                    self.message(('error', 'Third connection attempt detected.'))

        return preferred, fallback

class LoopbackScenario(Scenario):
    name = 'loopback'

    def prepare(self):
        super(self.__class__, self).prepare()
        os.environ['SOURCE'] = os.environ['DESTINATION'] = 'localhost'
        self._add_netns('test-loopback')

    def command(self, name, origin):
        return [
                'ip',
                'netns',
                'exec',
                'test-loopback',
                'wrapresolve',
                'testcases/{}/{}'.format(name, origin)]

class DualstackScenario(Scenario):
    name = 'dualstack'

    source_ns = 'test-client'
    destination_ns = 'test-server'
    source_link, destination_link = source_ns, destination_ns
    destination_config = ['192.0.2.1/24', '2001:DB8::2:1/64']
    source_config = ['192.0.2.2/24', '2001:DB8::2:2/64']

    def prepare(self):
        super(DualstackScenario, self).prepare()
        os.environ['SOURCE'] = 'client.example.net'
        os.environ['DESTINATION'] = 'server.example.net'
        for ns in self.source_ns, self.destination_ns:
            self._add_netns(ns)
        self._add_veth(self.source_ns, self.destination_ns)
        for address in self.source_config:
            self._add_address(self.source_ns, self.source_link, address)
        for address in self.destination_config:
            self._add_address(self.destination_ns, self.destination_link, address)

    def command(self, name, origin):
        return [
                'ip',
                'netns',
                'exec',
                'test-{}'.format(origin),
                'wrapresolve',
                'testcases/{}/{}'.format(name, origin)]

    def postprocess(self):
        preferred, fallback = self._connections()

        log.debug([fallback == preferred])

        self.testcase.properties.append(ParallelConnect(bool(fallback)))

class IP6DroppedScenario(DualstackScenario):
    name = 'v6dropped'

    def prepare(self):
        super(IP6DroppedScenario, self).prepare()
        subprocess.check_call(['ip', 'netns', 'exec', 'test-client', 'ip6tables', '-A', 'OUTPUT', '-j', 'DROP'])

    def postprocess(self):
        preferred, fallback = self._connections()

        if preferred and fallback:
            self.testcase.properties.append(FallbackDelay(fallback.socket.time - preferred.socket.time))

class Testcase:
    scenario_classes = [LoopbackScenario, DualstackScenario, IP6DroppedScenario]

    def __init__(self, name, scenarios=None):
        self.name = name
        self.scenarios = [cls(self) for cls in self.scenario_classes]
        if scenarios:
            self.scenarios = [scenario for scenario in self.scenarios if scenario.name in scenarios]
        self.properties = []

    def run(self):
        for scenario in self.scenarios:
            scenario.run()

    def report(self):
        print(self.name)
        print("  Scenarios:")
        for scenario in self.scenarios:
            scenario.report()
        print("  Properties:")
        for property in self.properties:
            print("    {}".format(property))
        print()

class TestSuite:
    def __init__(self, testcases=None, scenarios=None):
        self.testcases = [Testcase(name, scenarios) for name in os.listdir('testcases')]
        if testcases:
            self.testcases = [testcase for testcase in self.testcases if testcase.name in testcases]

    def run(self):
        for testcase in self.testcases:
            testcase.run()

    def report(self):
        print()
        for testcase in self.testcases:
            testcase.report()

def main():
    parser = argparse.ArgumentParser(description="Test driver for client-server networking applications.")
    parser.add_argument("--list", "-l", action="store_true", help="List testcases and scenarios.")
    parser.add_argument("testcases", nargs="?")
    parser.add_argument("scenarios", nargs="?")
    options = parser.parse_args()

    testcases = options.testcases and options.testcases
    scenarios = options.scenarios and options.scenarios

    suite = TestSuite(testcases, scenarios)
    if not options.list:
        suite.run()
    print(suite)
    print(suite.testcases)
    suite.report()

if __name__ == '__main__':
    main()
