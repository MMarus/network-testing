#!/usr/bin/python

from __future__ import print_function

import os, sys, subprocess, errno
import collections, functools, itertools
import logging
import time
import argparse
import socket

import ptrace.debugger
import ptrace.func_call
import ptrace.syscall

logging.basicConfig(level=logging.DEBUG, format="%(message)s")
log = logging.getLogger('tests')

import patch

class Socket:
    def __init__(self, syscall):
        self.fd = syscall.result
        self.domain, self.socktype, self.protocol = syscall.arguments
        self.time = syscall.time

    def __str__(self):
        return "{fd}/{domain.text}/{socktype.text}/{protocol.text}".format(**vars(self))

class Event:
    def __init__(self, syscall_event, time):
        self.origin = syscall_event.process.origin
        self.pid = syscall_event.process.pid
        self.name = syscall_event.name
        self.result = syscall_event.result
        self.arguments = syscall_event.arguments
        self.time = time
        self.__string = "[{time:.3f} {origin} {pid}] {format} = {result}".format(format=syscall_event.format(), **vars(self))

    def __str__(self):
        return self.__string

class Property:
    def __init__(self, arg):
        self.arg = arg

    def __str__(self):
        return self.template.format(**vars(self))

    def __repr__(self):
        return repr(str(self))

class IP4Listening(Property):
    template = "Listening on IPv4: {arg}"

class IP6Listening(Property):
    template = "Listening on IPv6: {arg}"

class PreferredFamily(Property):
    template = "Preferred address family is {arg}."

class PreferredLoopbackFamily(PreferredFamily):
    template = "Preferred loopback address family is {family}."

class ParallelConnect(Property):
    template = "Connection method is {method}. {description}"

    def __init__(self, flag):
        if flag:
            self.method = "parallel"
            self.description = "This is a happy eyeballs style dual-stack connection method resulting in fast fallback when the preferred address family fails silently."
        else:
            self.method = "sequential"
            self.description = "This is a classic dual-stack connection method resulting in a significant timeout when the preferred address family fails silently."

class FallbackDelay(Property):
    template = "Fallback delay is {arg:.3f}."

class Scenario(object):
    client = server = None
    ip = subprocess.check_output(['which', 'ip']).strip()

    def __init__(self, testcase):
        self.namespaces = []
        self.testcase = testcase
        self.messages = []
        self.sockets = {}
        self.events = []

    def wait(self, origin=None, syscall=None):
        while self.debugger.dict:
            try:
                process = self.debugger.waitSyscall().process
                event = Event(process.syscall_state.event(ptrace.func_call.FunctionCallOptions()), time.time() - self.started)
            except ptrace.debugger.process_event.NewProcessEvent as event:
                process = event.process
                origin = process.origin = process.parent.origin

                log.info("[{}] New process: {}".format(origin, process.pid))

                event.process.parent.syscall()
                process.syscall()
            except ptrace.debugger.process_event.ProcessExit as event:
                process = event.process
                origin = process.origin

                log.debug("[{}] Process exited: {} {}".format(origin, process.pid, event.exitcode))
                if process == self.server:
                    if self.debugger.dict:
                        self.message("Server returned but there are still processes running.")
                    if event.exitcode:
                        self.message("Server returned with non-zero exit code.")
                if process == self.client:
                    self.message("Client exit code is {}.".format(event.exitcode))
                    log.info("Client is gone, exiting.")
                    break;
            except ptrace.debugger.ptrace_signal.ProcessSignal as event:
                process = event.process
                origin = process.origin
                log.debug("[{}] Signal received: {} {}".format(origin, process.pid, event.signum))

                process.syscall(event.signum & ~0x80)
            else:
                if event.result is not None:
                    names = ptrace.syscall.SOCKET_SYSCALL_NAMES | set(['close', 'execve', 'fork', 'clone'])
                    if event.name == 'close':
                        if not self.sockets.pop((event.pid, event.arguments[0].value), None):
                            process.syscall()
                            continue
                    if event.name in set(['bind', 'listen', 'connect']):
                        event.socket = self.sockets[event.pid, event.arguments[0].value]
                    if event.name in names:
                        log.debug(event)
                        self.events.append(event)
                        if event.origin == 'server':
                            self.server_syscall(event)
                        elif event.origin == 'client':
                            self.client_syscall(event)
                    if event.origin == origin and event.name == syscall:
                        process.syscall()
                        return event

                process.syscall()


    def run(self):
        self.prepare()
        try:
            self.debugger = ptrace.debugger.PtraceDebugger()
            self.debugger.traceFork()
            self.started = time.time()

            log.info("\n*** {} / {} ***\n".format(self.testcase.name, self.name))

            try:
                self.server = self.start("server")
                self.wait("server", "listen")
                self.wait("server", "listen")

                self.client = self.start('client')
                self.wait()
            except BaseException as error:
                self.error("Python exception {} occured: {}".format(type(error), error))
                raise
        finally:
            self.debugger.quit()
            self.cleanup()
        self.postprocess()

    def server_syscall(self, syscall):
        if syscall.name == 'socket':
            sock = Socket(syscall)
            if sock.fd >= 0:
                self.sockets[syscall.pid, sock.fd] = sock
            else:
                self.error("Server failed to create socket: {}".format(sock))
        if syscall.name == 'bind':
            sock = self.sockets[syscall.pid, syscall.arguments[0].value]

            if syscall.result != 0 and sock.domain.text not in self.listening:
                self.listening.add(sock.domain.text)

                if 'AF_INET' in self.listening and 'AF_INET6' in self.listening:
                    self.client = self.start('client')

        if syscall.name == 'listen':
            sock = self.sockets[syscall.pid, syscall.arguments[0].value]

            if sock.domain.value == socket.AF_INET:
                self.message(IP4Listening(True))
            elif sock.domain.value == socket.AF_INET6:
                self.message(IP6Listening(True))

    def client_syscall(self, syscall):
        if syscall.name == 'socket':
            sock = Socket(syscall)
            if sock.fd >= 0:
                self.sockets[syscall.pid, sock.fd] = sock
            else:
                self.error("Client failed to create socket: {}".format(sock))
        if syscall.name == 'close':
            sock = self.sockets.pop((syscall.pid, syscall.arguments[0].value), None)
        if syscall.name == 'connect':
            sock = self.sockets.get((syscall.pid, syscall.arguments[0].value))
            if syscall.result == 0:
                if sock.protocol.value != 0:
                    self.info("Client connected: {} -> {}".format(sock, syscall))
            elif syscall.result == -errno.EINPROGRESS:
                self.info("Client connecting in non-blocking mode.")
            else:
                self.error("Client failed to connect: {} -> {}".format(sock, syscall))

    def start(self, origin):
        command = self.command(self.testcase.name, origin)

        log.debug("Starting {origin}: {command}".format(**locals()))
        try:
            pid = ptrace.debugger.child.createChild(command, False)
        except ptrace.debugger.child.ChildError:
            self.info("Script '{}' not found.".format(name))
            pid = ptrace.debugger.child.createChild(['/bin/true'], False)

        process = self.debugger.addProcess(pid, True)
        process.origin = origin
        process.syscall()

        return process

    def client_exited(self):
        pass

    def error(self, message):
        self.message(('error', message))

    def info(self, message):
        self.message(('info', message))

    def __str__(self):
        return self.name

    def prepare(self):
        os.environ['NETRESOLVE_BACKENDS'] = 'any|loopback|numerichost|hosts';
        os.environ['NETRESOLVE_SYSCONFDIR'] = os.getcwd();
        os.environ['DEFAULT_SERVICE'] = 'http'

    def cleanup(self):
        for ns in self.namespaces:
            subprocess.call(['ip', 'netns', 'delete', ns])

    def postprocess(self):
        pass

    def _add_netns(self, ns):
        self.namespaces.append(ns)
        subprocess.call(['ip', 'netns', 'delete', ns])
        subprocess.check_call(['ip', 'netns', 'add', ns])
        subprocess.check_call(['ip', '-n', ns, 'link', 'set', 'lo', 'up'])

    def _add_veth(self, ns1, ns2):
        link1, link2 = ns1, ns2
        subprocess.check_call(['ip', 'link', 'add', 'dev', link1, 'type', 'veth', 'peer', 'name', link2])
        for ns, link in (ns1, link1), (ns2, link2):
            subprocess.check_call(['ip', 'link', 'set', link, 'netns', ns, 'up'])

    def _add_address(self, ns, link, address):
        subprocess.check_call(['ip', '-n', ns, 'address', 'add', address, 'dev', link])

    def message(self, message):
        self.messages.append(message)

    def report(self):
        print('    ' + self.name)
        for message in self.messages:
            print('      ' + str(message))

    def _connections(self):
        preferred = None
        fallback = None

        for event in self.events:
            if event.origin == 'client' and event.name == 'connect':
                if event.arguments[1].text.startswith('<sockaddr_in sin_family=2, sin_port=0,'):
                    continue
                if event.arguments[1].text.startswith('<sockaddr_in6 sin6_family=10, sin6_port=0, sin6_flowinfo=0L,'):
                    continue

                if preferred is None:
                    preferred = event
                elif fallback is None:
                    fallback = event
                else:
                    self.message(('error', 'Third connection attempt detected.'))

        return preferred, fallback

class LoopbackScenario(Scenario):
    name = 'loopback'

    def prepare(self):
        super(self.__class__, self).prepare()
        os.environ['SOURCE'] = os.environ['DESTINATION'] = 'localhost'
        self._add_netns('test-loopback')

    def command(self, name, origin):
        return [
                self.ip,
                'netns',
                'exec',
                'test-loopback',
                'wrapresolve',
                'testcases/{}/{}'.format(name, origin)]

class DualstackScenario(Scenario):
    name = 'dualstack'

    source_ns = 'test-client'
    destination_ns = 'test-server'
    source_link, destination_link = source_ns, destination_ns
    destination_config = ['192.0.2.1/24', '2001:DB8::2:1/64']
    source_config = ['192.0.2.2/24', '2001:DB8::2:2/64']

    def prepare(self):
        super(DualstackScenario, self).prepare()
        os.environ['SOURCE'] = 'client.example.net'
        os.environ['DESTINATION'] = 'server.example.net'
        for ns in self.source_ns, self.destination_ns:
            self._add_netns(ns)
        self._add_veth(self.source_ns, self.destination_ns)
        for address in self.source_config:
            self._add_address(self.source_ns, self.source_link, address)
        for address in self.destination_config:
            self._add_address(self.destination_ns, self.destination_link, address)

    def command(self, name, origin):
        return [
                self.ip,
                'netns',
                'exec',
                'test-{}'.format(origin),
                'wrapresolve',
                'testcases/{}/{}'.format(name, origin)]

    def postprocess(self):
        preferred, fallback = self._connections()

        log.debug([fallback == preferred])

        self.testcase.properties.append(ParallelConnect(bool(fallback)))

class IP6DroppedScenario(DualstackScenario):
    name = 'v6dropped'

    def prepare(self):
        super(IP6DroppedScenario, self).prepare()
        subprocess.check_call(['ip', 'netns', 'exec', 'test-client', 'ip6tables', '-A', 'OUTPUT', '-j', 'DROP'])

    def postprocess(self):
        preferred, fallback = self._connections()

        if preferred and fallback:
            self.testcase.properties.append(FallbackDelay(fallback.socket.time - preferred.socket.time))

class Testcase:
    scenario_classes = [LoopbackScenario, DualstackScenario, IP6DroppedScenario]

    def __init__(self, name, scenarios=None):
        self.name = name
        self.scenarios = [cls(self) for cls in self.scenario_classes]
        if scenarios:
            self.scenarios = [scenario for scenario in self.scenarios if scenario.name in scenarios]
        self.properties = []

    def run(self):
        for scenario in self.scenarios:
            scenario.run()

    def report(self):
        print(self.name)
        print("  Scenarios:")
        for scenario in self.scenarios:
            scenario.report()
        print("  Properties:")
        for property in self.properties:
            print("    {}".format(property))
        print()

class TestSuite:
    def __init__(self, testcases=None, scenarios=None):
        self.testcases = [Testcase(name, scenarios) for name in os.listdir('testcases')]
        if testcases:
            self.testcases = [testcase for testcase in self.testcases if testcase.name in testcases]

    def run(self):
        for testcase in self.testcases:
            testcase.run()

    def report(self):
        print()
        for testcase in self.testcases:
            testcase.report()

def main():
    parser = argparse.ArgumentParser(description="Test driver for client-server networking applications.")
    parser.add_argument("--list", "-l", action="store_true", help="List testcases and scenarios.")
    parser.add_argument("testcases", nargs="?")
    parser.add_argument("scenarios", nargs="?")
    options = parser.parse_args()

    testcases = options.testcases and options.testcases.split(',')
    scenarios = options.scenarios and options.scenarios.split(',')

    suite = TestSuite(testcases, scenarios)
    if not options.list:
        suite.run()
    suite.report()

if __name__ == '__main__':
    main()
