#!/usr/bin/python

from __future__ import print_function

import os, sys, subprocess, errno
import collections, functools, itertools
import argparse
import socket
import re

import debug
import ptrace.debugger

import logging
logging.basicConfig(level=logging.DEBUG, format="%(message)s")
log = logging.getLogger('tests')

SOCKET_OPERATIONS = set(['bind', 'listen', 'accept', 'connect', 'getsockopt', 'shutdown', 'close'])
PROCESS_SYSCALLS = set(['close', 'execve', 'fork', 'clone'])

class Property:
    def __init__(self, arg):
        self.arg = arg

    def __str__(self):
        return self.template.format(**vars(self))

    def __repr__(self):
        return repr(str(self))

class IP4Listener(Property):
    template = "Listens on IPv4: {arg}"

class IP6Listener(Property):
    template = "Listens on IPv6: {arg}"

class IP4Connection(Property):
    template = "Attempts IPv4 connection: {arg}"

class IP6Connection(Property):
    template = "Attempts IPv6 connection: {arg}"

class PreferredFamily(Property):
    template = "Preferred address family is {arg}."

class PreferredLoopbackFamily(PreferredFamily):
    template = "Preferred loopback address family is {family}."

class ParallelConnect(Property):
    template = "Connection method is {method}. {description}"

    def __init__(self, flag):
        if flag:
            self.method = "parallel"
            self.description = "This is a happy eyeballs style dual-stack connection method resulting in fast fallback when the preferred address family fails silently."
        else:
            self.method = "sequential"
            self.description = "This is a classic dual-stack connection method resulting in a significant timeout when the preferred address family fails silently."

class FallbackDelay(Property):
    template = "Fallback delay is {arg:.3f}."

class Scenario(object):
    client = server = None

    def __init__(self, testcase):
        self.expected_exitcodes = {'server': 0, 'client': 0}
        self.namespaces = []
        self.testcase = testcase
        self.messages = []
        self.listeners = []
        self.connections = []

    def __str__(self):
        return self.name

    def run(self):
        debugger = debug.SyscallDebugger()

        # Run entities and collect syscalls.
        self.prepare()
        try:
            log.info("\n*** {} / {} ***\n".format(self.testcase.name, self.name))

            try:
                self.server = self.start(debugger, "server")
                debugger.set_timeout(35)
                debugger.wait("server", "listen")
                debugger.set_timeout(5)
                debugger.wait("server", "listen")

                self.client = self.start(debugger, "client")
                debugger.set_timeout(20)
                debugger.wait()
            except debug.Timeout:
                self.message("Timeout occured.")
            except BaseException as error:
                self.message("Python exception {} occured: {}".format(type(error), error))
                raise
        finally:
            debugger.quit()
            self.cleanup()

        self.events = debugger.events
        del debugger

        # Process collected events.
        for event in self.events:
            if isinstance(event, ptrace.debugger.process_event.ProcessExit):
                if event.exitcode != self.expected_exitcodes[event.origin]:
                    self.message("Unexpected {} exit code {}.".format(event.origin, event.exitcode))
                if event.process == self.server:
                    self.message("Client exit code is {}.".format(event.exitcode))
                if event.process == self.client:
                    self.message("Server exit code is {}.".format(event.exitcode))
            elif event.name == 'listen':
                if event.origin != 'server':
                    continue
                self.listeners.append(event.socket)
            elif event.name == 'connect':
                if event.origin != 'client':
                    continue
                if re.search(" sin6?_port=0, ", event.arguments[1].text):
                    continue
                conn = event.socket
                conn.attempted = event.time
                conn.status = event.result
                conn.nonblocking = conn.status == errno.EINPROGRESS
                self.connections.append(conn)
            elif event.name == 'getsockopt':
                if event.origin != 'client':
                    continue
                if event.arguments[1].value != socket.SOL_SOCKET:
                    continue
                if event.arguments[2].value != socket.SO_ERROR:
                    continue
                event.socket.status = event.arguments[3].value


        # Postprocess acquired data.
        self.postprocess()

    def start(self, debugger, origin):
        command = self.command(self.testcase.name, origin)

        try:
            return debugger.new_child(origin, command)
        except ptrace.debugger.child.ChildError:
            self.message("Script '{}' not found.".format(name))
            return debugger.new_child(origin, ['/bin/true'])

    def prepare(self):
        os.environ['NETRESOLVE_BACKENDS'] = 'any|loopback|numerichost|hosts';
        os.environ['NETRESOLVE_SYSCONFDIR'] = os.getcwd();
        os.environ['DEFAULT_SERVICE'] = 'http'

    def cleanup(self):
        for ns in self.namespaces:
            subprocess.call(['ip', 'netns', 'delete', ns])

    def postprocess(self):
        pass

    def _add_netns(self, ns):
        self.namespaces.append(ns)
        subprocess.call(['ip', 'netns', 'delete', ns])
        subprocess.check_call(['ip', 'netns', 'add', ns])
        subprocess.check_call(['ip', '-n', ns, 'link', 'set', 'lo', 'up'])

    def _add_veth(self, ns1, ns2):
        link1, link2 = ns1, ns2
        subprocess.check_call(['ip', 'link', 'add', 'dev', link1, 'type', 'veth', 'peer', 'name', link2])
        for ns, link in (ns1, link1), (ns2, link2):
            subprocess.check_call(['ip', 'link', 'set', link, 'netns', ns, 'up'])

    def _add_address(self, ns, link, address):
        subprocess.check_call(['ip', '-n', ns, 'address', 'add', address, 'dev', link])

    def message(self, message):
        self.messages.append(message)

    def report(self):
        print('    ' + self.name)
        for message in self.messages:
            print('      ' + str(message))

class LoopbackScenario(Scenario):
    name = 'loopback'

    def prepare(self):
        super(self.__class__, self).prepare()
        os.environ['SOURCE'] = os.environ['DESTINATION'] = 'localhost'
        self._add_netns('test-loopback')

    def command(self, name, origin):
        return ['ip', 'netns', 'exec', 'test-loopback', 'wrapresolve', 'testcases/{}/{}'.format(name, origin)]

class DualstackScenario(Scenario):
    name = 'dualstack'

    source_ns = 'test-client'
    destination_ns = 'test-server'
    source_link, destination_link = source_ns, destination_ns
    destination_config = ['192.0.2.1/24', '2001:DB8::2:1/64']
    source_config = ['192.0.2.2/24', '2001:DB8::2:2/64']

    def prepare(self):
        super(DualstackScenario, self).prepare()
        os.environ['SOURCE'] = 'client.example.net'
        os.environ['DESTINATION'] = 'server.example.net'
        for ns in self.source_ns, self.destination_ns:
            self._add_netns(ns)
        self._add_veth(self.source_ns, self.destination_ns)
        for address in self.source_config:
            self._add_address(self.source_ns, self.source_link, address)
        for address in self.destination_config:
            self._add_address(self.destination_ns, self.destination_link, address)

    def command(self, name, origin):
        return ['ip', 'netns', 'exec', 'test-{}'.format(origin), 'wrapresolve', 'testcases/{}/{}'.format(name, origin)]

    def postprocess(self):
        self.testcase.add_property(IP4Listener(bool([listener for listener in self.listeners if listener.domain.value == socket.AF_INET])))
        self.testcase.add_property(IP6Listener(bool([listener for listener in self.listeners if listener.domain.value == socket.AF_INET6])))
        print(self.connections)
        self.testcase.add_property(ParallelConnect(len(self.connections) > 1))

class IP6DroppedScenario(DualstackScenario):
    name = 'v6dropped'

    def __init__(self):
        super(IP6DroppedScenario, self).__init__()

    def prepare(self):
        super(IP6DroppedScenario, self).prepare()
        subprocess.check_call(['ip', 'netns', 'exec', 'test-client', 'ip6tables', '-A', 'OUTPUT', '-j', 'DROP'])

    def postprocess(self):
        self.testcase.add_property(IP4Connection(bool([conn for conn in self.connections if conn.domain.value == socket.AF_INET])))
        self.testcase.add_property(IP6Connection(bool([conn for conn in self.connections if conn.domain.value == socket.AF_INET6])))

        if len(self.connections) > 1:
            preferred, fallback = self.connections[:2]
            self.testcase.add_property(FallbackDelay(fallback.attempted - preferred.attempted))

class Testcase:
    scenario_classes = [LoopbackScenario, DualstackScenario, IP6DroppedScenario]

    def __init__(self, name, scenarios=None):
        self.name = name
        self.scenarios = [cls(self) for cls in self.scenario_classes]
        if scenarios:
            self.scenarios = [scenario for scenario in self.scenarios if scenario.name in scenarios]
        self.properties = {}

    def run(self):
        for scenario in self.scenarios:
            scenario.run()

    def add_property(self, prop):
        self.properties[type(prop)] = prop

    def report(self):
        print(self.name)
        print("  Scenarios:")
        for scenario in self.scenarios:
            scenario.report()
        print("  Properties:")
        for property in sorted(self.properties.values()):
            print("    {}".format(property))
        print()

class TestSuite:
    def __init__(self, testcases=None, scenarios=None):
        self.testcases = [Testcase(name, scenarios) for name in os.listdir('testcases')]
        if testcases:
            self.testcases = [testcase for testcase in self.testcases if testcase.name in testcases]

    def run(self):
        for testcase in self.testcases:
            testcase.run()

    def report(self):
        print()
        for testcase in self.testcases:
            testcase.report()

def main():
    parser = argparse.ArgumentParser(description="Test driver for client-server networking applications.")
    parser.add_argument("--list", "-l", action="store_true", help="List testcases and scenarios.")
    parser.add_argument("testcases", nargs="?")
    parser.add_argument("scenarios", nargs="?")
    options = parser.parse_args()

    testcases = options.testcases and options.testcases.split(',')
    scenarios = options.scenarios and options.scenarios.split(',')

    suite = TestSuite(testcases, scenarios)
    if not options.list:
        suite.run()
    suite.report()

if __name__ == '__main__':
    main()
